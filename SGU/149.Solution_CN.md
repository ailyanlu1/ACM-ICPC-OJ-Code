# SGU 149 Computer Network

## Summary
给出一棵树，树上的边是带权的。然后询问每个节点与离他最远的那个点的距离。

题目的输入有点奇怪。其实输入n后，下面是第i+1（也就是2-n）顶点的父节点，第二个数字为那条边的边权。那么意味着1可以看作树的一个根。
## Solution

经典的Tree DP。使用四个数组记录：d1[]：当前节点，到其下最远的距离。
p1[]：记录d1这个最优值是由哪个子树获得的。
d2[]：当前节点，到其下次远的距离。其实这个次远不不一定是真正的次远。而是应该表达为：除了走最远的那棵子树意外，走其他子树而得到的最远距离。因此，这个次远值有可能和最远值相等。
d3[]：当前节点，通过其父向上走能够达到的最远距离。

那么明显，对于一个节点，Max(d1[i], d3[i])就是答案。d1,d2的状态转移比较简单。根据定义，先算出一个节点的d1值，然后再去更新d2的值就可以了。

d3的值可以在另一次dfs中完成。每个节点的d3的值都是通过父亲节点向下传的。设f为p的父节点，有
```c
max(d, d2[x]) + G[x][i].d //p是d1[f]这个最优值所获得的子树
max(d, d1[x]) + G[x][i].d //p不是d1[f]这个最优值所获得的子树
```
