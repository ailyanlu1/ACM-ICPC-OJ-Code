# The 2008 Asia Regional Contest - Chengdu

<table>
<thead>
<th width='40px' align='center'>Id</th>
<th width='500px' align='left'>Problem</th>
<th width='130px' align='left'>Link</th>
<th width='80px' align='left'>Code</th>
</thead>
<tbody>
<tr><td>A</td>   <td>Process scheduling</td>   <td>LA 4392</td>   <td><a href='la4392.cpp'>C++</a></td>   </tr>
<tr><td>B</td>   <td>Box</td>   <td>LA 4393</td>   <td><a href='la4393.cpp'>C++</a></td>   </tr>
<tr><td>C</td>   <td>String painter</td>   <td>LA 4394</td>   <td><a href='la4394.cpp'>C++</a></td>   </tr>
<tr><td>D</td>   <td>Crop circles</td>   <td></td>   <td></td>   </tr>
<tr><td>E</td>   <td>Slides</td>   <td>LA 4396</td>   <td><a href='la4396.cpp'>C++</a></td>   </tr>
<tr><td>F</td>   <td>Kingdoms</td>   <td></td>   <td></td>   </tr>
<tr><td>G</td>   <td>Steal the Treasure</td>   <td>LA 4398</td>   <td><a href='la4398.cpp'>C++</a></td>   </tr>
<tr><td>H</td>   <td>Toy</td>   <td></td>   <td></td>   </tr>
<tr><td>I</td>   <td>Transit search</td>   <td>LA 4400</td>   <td><a href='la4400.cpp'>C++</a></td>   </tr>
<tr><td>J</td>   <td>Counting square</td>   <td>LA 4401</td>   <td><a href='la4401.cpp'>C++</a></td>   </tr>
<tr><td>K</td>   <td>Build the Tower</td>   <td></td>   <td></td>   </tr>
</tbody>
</table>


## Problem A. Process scheduling

OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4392			| C++		| Accepted      | 0.228 s / 3.000 s    	      |
HDU 2478							| C++		| Accepted      | 280 ms / 3000 ms     	      |

##### Summary
一个操作系统资源分配的问题。系统里面有m(m<=3)种资源，有n(n<=50000)个进程。现在已经知道：每个资源的可用数量，以及当前每个进程占用的每个资源的数目。并给出这些进程要继续完成任务所需要额外的资源。求是否存在一个进程的执行顺序，使所有进程都利用可用的资源执行完毕。（进程结束后，会把其占用的资源释放，使其变为可用资源）。
##### Solution
数据结构。

算法的框架是：不停找出可以执行的进程，然后释放其资源，直到所有进程执行完毕为止。如果中途资源不足以执行任何一个进程，就返回No。

但是因为n非常大，O(n<sup>2</sup>)的算法效率会很低，所有我们需要有更好的方法去判断当前的可用资源可以满足哪个进程的要求。这时需要优先队列：

创建m个优先队列q<sub>1</sub>, q<sub>2</sub>...q<sub>m</sub>。这些优先队列原来存储进程。每一个优先队列q<sub>i</sub>是按照进程对资源i的需求从小到大整理的。一开始先把所有进程放进q<sub>1</sub>，然后不停执行这个过程：从q<sub>1</sub>中取出所有当前资源1能满足的进程，放到q<sub>2</sub>里。然后从q<sub>2</sub>取出当前资源2能满足的进程，放到q<sub>3</sub>里……直到q<sub>m</sub>，从q<sub>m</sub>中取出当前可以资源m能满足的进程，就是利用当前可用资源可以执行的进程。把这些进程执行掉（也就是把他们占用的资源释放掉），再从头执行算法。随着进程的结束，可用的资源只会越来越多，优先队列q<sub>i</sub>里面的进程会不停推进到q<sub>i+1</sub>里面。上述算法执行过程中，如果在某个队列q<sub>i</sub>里面找不到能资源i能满足的进程，就说明遇到死锁了。



## Problem B. Box

OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4393			| C++		| Accepted      | 0.965 s / 3.000 s    	      |

##### Summary
维护一个由有根树组成的森林，每次可以把一棵子树转移到某个节点X的下方，子树本身结构不变(即改变该子树根Y的父节点)。如果X本来就是Y这棵子树中则忽略此次操作。同时需要回答一些询问，每次询问某个节点所在树的根节点是谁。
##### Solution
此题的一个重要性质：每次转移子树后原子树的结构是不变的。因此当我们采用DFS序列表示树形态时，每次转移实际上就相当于转移序列的一段区间。而这个操作可以用伸展树很好地解决。

实际操作时,我们用括号序列来表示DFS序列，每个节点进栈时是左括号，出栈是右括号。这样以任一节点为根的子树都可以用被该节点的左右括号括起来的序列表示。每次转移直接把这段区间“剪”下来，再插入到目标节点的左括号后面即可。例如，题目的样例数据“0 6 4 6 1 0”可以表示为（括号右面的数字表示对应的矩形编号）：

'''
(6 (2  2) (4 (3 3) 4) 6) (1 (5 5) 1)
'''

至于询问某节点P所在树的根，实际就是询问该节点所在的DFS序列的首节点，也就是把P提根后的左路径最后一个节点。

而判断某节点X是否在某一棵子树内，只需先把那棵子树“剪”下来，再查询X所在树的根即可。

在本题的splay树中，T表示节点数组，每个i代表左括号，i+n代表右括号。每次splay操作都必须将指定的点旋转到SPLAY树的顶端。而且这个题目是多个splay树。随时要进行各种分割与合并操作。我的splay树用的是自底向上的旋转方法，效率比较低。

Live Archive上的数据有点诡异，scanf不能用EOF判断，否则读数据时就TLE了。


## Problem C. String painter


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4394			| C++		| Accepted      | 0.019 s / 3.000 s    	      |


##### Solution
动态规划。定义DP状态方程是：dp[l,r,ch]。表示将字符串A的[i,j]刷成ch后，要到达B[i,j]需要的最小步数。若 ch=0，那么表示这一段为混合颜色，且A[i,j]=B[i,j]。有如下状态转移：

dp[l,r,ch]=min(dp[l+1,i-1,s[l]]+1+dp[i+1,r,ch]); (l<=i<=r && s[l]==s[i])

若B[l] = ch 且ch != 0，那么有dp[l][r][ch] = dfs(l+1, r, ch)。 若B[l] = A[l] 且ch == 0，那么有dp[l][r][ch] = dfs(l+1, r, A[l])。 


## Problem E. Slides


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4396			| C++		| Accepted      | 0.003 s / 3.000 s    	      |
HDU 2478							| C++		| Accepted      | 234 ms / 3000 ms     	      |

##### Summary
有N(N<=100,000)个矩形，现在必须从这些矩形中删掉一个矩形，使剩下的矩形<b>的公共部分面积</b>最大。求这个最大的面积。

##### Solution
公共部分就是矩形的交。矩形求交这个运算满足“交换律”，因此可以预处理出两个数组：一个是forward，从前面开始计算，表示1到i之间所有矩形的交，一个是backward，从后面开始计算，表示i到n之间所有矩形的交。

有了这两个数组，就可以很方便地计算取掉某个矩形i以后，剩下的矩形的交就是：intersect(forward[i-1], backward[i+1])。处理好边界情况即可。

PS：ACM-ICPC Live Archive上面的数据貌似和HDU不一样。HDU里面N的范围是100,000，而Live Archive上面只有100。


## Problem G. Steal the Treasure


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4398			| C++		| Accepted      | 0.405 s / 3.000 s    	      |


##### Summary
原题的叙述有一定的问题，基本不可理解。题目实际的意思是：给出一个地图，地图上有若干城市，城市之间有道路相连。道路有的是双向的，有的是单向的。每条道路上都有一些财产。盗贼联盟向每个城市都派一个贼。这个贼从这个城市中选一条边出发，将这一条边的财产偷去。注意：有可能这个盗贼找不到可走的 边。问：盗贼联盟最多能偷多少财产。 
##### Solution

这个解题思路来自网上。

题目看上去貌似是个二分图最优匹配问题（n个顶点与m条边进行最大权匹配），不过无论是时间还是空间都是不允许进行这样规模的最大权匹配的。于是，我们再来看这个问题，最后的匹配是每个顶点都有且仅一条出该顶点的边，匹配的能否进行仅和该顶点可否使用有关，每条边只和一个顶点关联（若看成 全部都是有向边）。因此可以使用贪心的思路来解决这个问题：把所有边按权从大到小排序，然后依次验证边，把可行的边加入图中，最后就可以得到我们所要的匹配。

当匹配一条边的时侯，如果这条边的起点没有被匹配了，那么这条边就是可行的。但是这个题目有有向边和无向边两种类型。对于有向边，我们只要判断起始点是是否被匹配了即可；对于无向边(x,y)怎么办呢？

一个无向边有以下4种情况：

1. x有出边，y无出边
2. x无出边，y有出边
3. x无出边，y无出边
4. x有出边，y有出边 

1和2是对称的情况且很容易类似有向边的处理，虽然是无向边，但是方向已经确定了。4显然就是不用加这条边，所以实际上就是要解决情况3的处理。对 于情况3，我们想象一些顶点靠无向边连在一起，那么他们之间的边的方向就可以有2种选择，然后，我们无论在其中哪一个顶点上添加一条有向边（不论是出还是 入），与该顶点相连边的方向都会得到确定，进而所有这些顶点之间的无向边的方向就会得到确定，于是就又归结到了有向边的情形。我们得到情况3的处理方法： 合并x和y所属的集合。这就很自然导出了并查集的实现，前面的讨论有些地方就需要改成”选取所在集合“了。

需要注意的是，我们还没有讨论环的情况，那么成环会是什么样的情形呢？由n个顶点组成的点集，根据题目要求，最多只能加n条边，于是n条边 最多也就能成若干个简单环，不可能形成双环。因此，在一个环中，所有的顶点都是不能再被匹配的。 






## Problem I. Transit search


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4398			| C++		| Accepted      | 0.039 s / 3.000 s    	      |


##### Solution
带模拟背景的搜索题，只要把步骤列出来，逐个击破即可。

要注意题目的规模，这个题目的特点是：车站很多，有5000个，但是路线很少，只有100条，而且每条路线的车站不超过30个。因此我们应 该这样广搜：用图表示路线之间的换乘关系，如果可以换乘，则为1，不能换乘，则为0。只要表示出来，那么就可以转化成一个BFS搜无权最短路的问题。只要实现好预处理，那么这个问题就变得很容易解决了。

1. 根据给出的起点和终点，得出实际的起点和终点坐标。
2. 读入各个车站的信息，存储，并判断哪些车站与起点或终点相连，标记之。
3. 读入路线的信息。
4. 通过枚举，建图，路线若可以换乘，也就是有公用站点的，那么就连一条边。在我的算法中，这一步可以在O(n2k) 时间内完成。
5. 同时标记哪些线路是与起点站相连，哪些路线是与终点站相连。
6. 枚举每个与起点站相连的路线，广搜最优换乘次数。 

附带的代码，运行起来相当快。 


## Problem J. Counting square


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4398			| C++		| Accepted      | 0.309 s / 3.000 s    	      |


##### Solution
一开始必须先作O(N<sup>2</sup>)的预处理，将原数组[i,j]以下的和，i以左的和，j以下的和预先计算出来。然后通过O(N<sup>3</sup>) 的枚举（枚举正方形的左上角和右下角）即可解决问题。注意下标不要弄错即可。 






