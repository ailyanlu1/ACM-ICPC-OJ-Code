# 2010 Hangzhou: Prison Break
## Solution

这题的做法很多。下面的代码是使用：bfs预处理，二分答案，然后再使用Dijskra求最“长”路判定。

我们留意到，给出的能量点和开关点加起来只有14个，因此提示我们这个可能需要使用状态压缩来处理。我的做法是：

1. 先拿出所有的能量点（G点）和开关点（Y点），以及起始位置，一共不超过15个。
2. 预处理这些点之间的距离。使用BFS即可
3. 然后就是一个类似哈密顿回路的问题，可以使用状态压缩动态规划解决判定给定能量能否走完所有点。由于我们预处理了点对之间的最短路，因此每个点最多只会经 过1次，而且我们是在解决判定性问题，因此只要一旦发现能够走完所有的Y点，那么就马上返回到主程序。而我使用的是Dijskra的方法：数组dp[x] [st]表示从起始点开始，到达x点，经过的点集为st（状态压缩表示）时，能够保留最大的能量（我们肯定是希望到达某个状态时，剩下的能量尽量多，这样 才会最优）。这时，状态大概只有15 * 2^14个，可以对Dijskra+堆算法稍加改造即可。在优先队列之中，我还增加了一个字段solve，表示已经经过了多少个Y点，这样每次从队列之中 取出状态时就可以知道是否已经走完了所有的Y点。 
