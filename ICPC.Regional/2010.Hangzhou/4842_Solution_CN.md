# 2010 Hangzhou: Infinite monkey theorem
## Solution

第一眼看上去像是一种AC自动机上面的动态规划，但是由于题目的规模很小，要出现的只有一个串，而且这个串的长度不超过10。因此可以使用一些简单而基础的做法解决。实际上此题可以使用二维的动态规划解决。

设DP数组DP[X][Y]表示，目标串为DEST，设LEN为目标串的长度，在第X次按键的时候，匹配目标串到第Y个（范围是0至 Len-1）字符，且之前没有出现过目标串时的概率。那么DP[X][0-LEN-1]，都表示匹配了目标串前Y个字母（也就是一个长为LEN+1的前 缀），还要增加一个状态DP[X][LEN]，表示没有匹配到DEST任何一个前缀的概率。

于是做动态规划的时候，就可以这样做： 每次枚举一个当前的状态dp[i][j]（匹配位置与一个前缀），再枚举在当前前缀S后面加入给出的字母表之中的一个字母CH[K]，S+CH[K]，组 成一个新的前缀NEXT。然后看看NEXT能够匹配到DEST的哪些前缀。当然，有可能仅仅是部分匹配（也就是NEXT的一个后缀匹配到了NEXT的一个 前缀），在这个时候，就取最长的NEXT的后缀，与DEST的一个前缀匹配（也就是一样），那么就把dp[i][j] * probibility[ch[k]]加入到dp[i+1][DEST被匹配的前缀长度]之中。没有匹配到DEST的任何一个前缀的时候要特殊处理一下。

最后统计一下dp[i][len-1]，全部加起来就是答案。

当前前缀加入字母表中的一个字母，组成NEXT，检查NEXT的后缀能够匹配哪个最长的DEST前缀，这一步是可以进行预处理的。由于题目规模很小，直接使用暴力方法进行预处理即可。 
