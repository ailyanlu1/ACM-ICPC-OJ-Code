<table>
<thead>
<th width='40px' align='center'>Id</th>
<th width='500px' align='left'>Problem</th>
<th width='130px' align='left'>Link</th>
<th width='80px' align='left'>Code</th>
</thead>
<tbody>
<tr><td>A</td>   <td>Trick or Treat</td>   <td></td>   <td></td>   </tr>
<tr><td>B</td>   <td>Working at the Restaurant</td>   <td></td>   <td></td>   </tr>
<tr><td>C</td>   <td>Lights</td>   <td></td>   <td></td>   </tr>
<tr><td>D</td>   <td>Darts</td>   <td></td>   <td></td>   </tr>
<tr><td>E</td>   <td>Genetics</td>   <td></td>   <td></td>   </tr>
<tr><td>F</td>   <td>Haunted Graveyard</td>   <td>LA 4509</td>   <td><a href='la4509.cpp'>C++</a></td>   </tr>
<tr><td>G</td>   <td>Slalom</td>   <td>LA 4510</td>   <td><a href='la4510.cpp'>C++</a></td>   </tr>
<tr><td>H</td>   <td>Routing</td>   <td></td>   <td></td>   </tr>
<tr><td>I</td>   <td>Happy Telephones</td>   <td>LA 4512</td>   <td><a href='la4512.cpp'>C++</a></td>   </tr>
<tr><td>J</td>   <td>Stammering Aliens</td>   <td>LA 4513</td>   <td><a href='la4513.cpp'>C++</a></td>   </tr>
</tbody>
</table>



## Problem F. Haunted Graveyard


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4509			| C++		| Accepted		| 0.236 s / 3.000 s			  |


##### Summary
一个N*M(N, M <= 30)的方格阵里面，每移动一次耗费1秒。其中有一些格子不能走，有一些格子可以“瞬移”到另一个格子，而且有可能会导致时间前进或者后退。现在问从(0,0)走到(N-1, M-1)所需的最短时间。如果不可能走到终点则输出Impossible。如果时间永远倒流，那么就输出Never。

##### Solution
带负权边的图的最短路。

因为时间可以“后退”，所以这个图是有负边的。因此这个问题可以用Bellman-Ford算法求解。需要注意的是，如果负环不可达，那么这个负环就不会对结果造成影响。此外，终点没有通往其他格子的边，所以不要对终点做松弛操作，否则有可能会走到另一个负环上。


## Problem G. Slalom


##### Summary

有一个人滑雪，二维平面坐标上有n(n<=1000)个滑雪门，人从起点出发，必须按顺序从这些门之间穿过去，到达最后一个门。问此人从起点到最后一个门的最短距离是多少？

滑雪门使用Y x1 x2表示，表示其两个端点是(x1, Y), (x2, Y)。且保证给出的门是按Y递减的顺序给出的。人只能够从门中间通过，不能绕门而行。
##### Solution

有一个结论：人滑雪的路线必定是由一些线段组成的。而且这些线段的端点必定是起点或者门的两个端点，并有可能有一条垂直于X轴的线段（最后一段，从 某个点直接滑到最后一个门）。

因此对于某端点（起点S或这门的端点）的PA和门B的端点PB（A.y > B.y），如果线段PA PB之间都经过其他门之内，就可以在有向图中连一条有向边。由于滑雪不会逆行回到前一个门，因此构造出来的图必定是一个DAG（有向无环图），可以使用DP求最短路。注意：如果一个点能够垂直到达最后一个门，那么就要检查到这个点的最短路加上垂直到达最后一个门的距离，与最优答案比较，并更新。

但要注意，由于题目的规模比较大，n达到1000，因此不能够枚举任意两个端点，再判断是否经过之间所有的门，这样的做法是O(n<sup>3</sup>)。因此需要有更加高效的方法来进行预处理。可以枚举某个点P，想象有一束光从这个点分散向下照射，下面的每个门相当一条能够通过光线的缝隙。对该点下面的线段逐条枚举，看看这束光线能够照射到下面的哪些线段端点。光线的左右范围可以使用两条射线的斜率的倒数保存（因为射线不可能平行于X轴，但是会平行于Y 轴，因此要用斜率的倒数）。如果这束光线能够照到最底下的门，那么就说明这个点能够直接垂直下到最小面的门，求最短路的时候要特判一下这种情况。 




## Problem I. Happy Telephones


##### Solution
简单题，直接做即可。 



## Problem J. Stammering Aliens


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4513			| C++		| Accepted		| 0.389 s / 3.000 s			  |


##### Summary
给出一个字符串（长度n<=40000），要找出一个最长的重复了至少K(k<=40000)次的最长的子串。这个子串在原串中可以重叠。如果存在这个子串，则输出这个最长的长度，并输出该子串最右可能出现的位置。如果不存在，则输出none。
##### Solution

首先判断是否可能存在这个子串，如果长度为1的子串也不可能，那么则输出none。

否则二分这个长度，把问题转化成判定性问题。之后可以使用后缀数组或者Hash解决。这里介绍使用Hash的方法。

二分长度K后，仿照RK Hash的方法，每次把字符串中长度为K的串Hash为一个值，存进一个Hash表中，同时统计这个值出现的次数。如果出现的次数大于题目给定的K，那么则更新答案。由于扫描是从右往左进行的，因此一旦发现满足题目要求的(>=K)可以直接更新RIGHT的。

Hash表可以使用前向星数组的Hash表存储，附加一个域存储该值出现的次数即可。




