<table>
<thead>
<th width='40px' align='center'>Id</th>
<th width='500px' align='left'>Problem</th>
<th width='130px' align='left'>Link</th>
<th width='80px' align='left'>Code</th>
</thead>
<tbody>
<tr><td>A</td>   <td>Trick or Treat</td>   <td>LA 4504</td>   <td><a href='la4504.cpp'>C++</a></td>   </tr>
<tr><td>B</td>   <td>Working at the Restaurant</td>   <td>LA 4505</td>   <td><a href='la4505.cpp'>C++</a></td>   </tr>
<tr><td>C</td>   <td>Lights</td>   <td></td>   <td></td>   </tr>
<tr><td>D</td>   <td>Darts</td>   <td>LA 4507</td>   <td><a href='la4507.cpp'>C++</a></td>   </tr>
<tr><td>E</td>   <td>Genetics</td>   <td></td>   <td></td>   </tr>
<tr><td>F</td>   <td>Haunted Graveyard</td>   <td>LA 4509</td>   <td><a href='la4509.cpp'>C++</a></td>   </tr>
<tr><td>G</td>   <td>Slalom</td>   <td>LA 4510</td>   <td><a href='la4510.cpp'>C++</a></td>   </tr>
<tr><td>H</td>   <td>Routing</td>   <td></td>   <td></td>   </tr>
<tr><td>I</td>   <td>Happy Telephones</td>   <td>LA 4512</td>   <td><a href='la4512.cpp'>C++</a></td>   </tr>
<tr><td>J</td>   <td>Stammering Aliens</td>   <td>LA 4513</td>   <td><a href='la4513.cpp'>C++</a></td>   </tr>
</tbody>
</table>


## Problem A. Trick or Treat


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4504			| C++		| Accepted		| 0.296 s / 3.000 s			  |


##### Summary

平面上有点集P(点的数目N<=50,000)。设y=0上一个点A，P中离A最远的点到A的距离为d。求A的坐标A(x<sub>a</sub>, 0)，使d最小。要求输出x<sub>a</sub>和d，且答案的误差小于1e-5。


##### Solution
最简单的O(n<sup>2</sup>)算法明显是不行的。看到这种“使最大最小”的问题，很容易想到二分法。这个题目有多个思路：

1. 最直观的想法是：二分这个最大距离d，再检查y=0上是否存在点A满足条件。这个检查很简单，枚举每个点，找出在y=0上满足点到直线距离小于d的区间，如果所有点的这些区间有公共部分，就证明点A是存在的。这个方法虽然容易想，但计算常数比较大，而且计算x<sub>a</sub>时精度是个大问题。满足误差小于1e-5的d并不一定使x<sub>a</sub>的误差同样小于1e-5。增大计算精度基本都会超时，所以这只是一种理论上正确的解法。

2. 另一个思路是：令一开始二分的上限r是所有点x的最大值，下限l是所有点x的最小值，然后二分点A的x坐标x<sub>a</sub>。如果P中距离这个二分点最远的点在其“右”边（也就是x<sub>far</sub> > mid），那么l=mid。否则，r=mid。这个很容易证明。如果P中距离这个二分点最远的点在其“右”边，就说明x还要“往右靠”，才能使d减少，所以答案的区间肯定落在右面。

3. 从思路2里面可以推出，d = f(x)（d为最远距离，x为A点的x坐标）是一个单峰函数，因此可以用三分法求极值。


## Problem B. Working at the Restaurant


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4505			| C++		| Accepted		| 0.003 s / 3.000 s			  |

##### Solution
模拟题，直接做。


## Problem D. Darts


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4507			| C++		| Accepted		| 0.106 s / 3.000 s			  |


##### Summary
有一个圆盘，分成20个格子，分数分别是1到20。A和B玩扔飞镖游戏。一开始他们各有N分（N<=501），他们轮流扔飞镖，扔中的格子是多少分，自己的分数就减去多少分，谁的分数先打到0分就胜利。如果减去格子的分数会得到负分的话（例如A分数是1，扔中5分的格子），那么分数就维持不变（A还是1分）。A的策略是随机扔，所以A投中每个格子的概率都是相等的。B的策略是瞄准使他胜率最大的格子扔，但他只有1/3的概率扔中那个格子，目标格子的两个相邻格子的命中几率也是1/3。

问，他们一开始都有N分的情况下，A先手赢的概率以及B先手赢的概率。
##### Solution
非常有意思的一个概率题。

设A有N分，B有M分，如果N或者M都大于20的话，那么这个问题是一个动态规划问题。设方程为p<sub>A</sub>(N, M)为此时A先手赢的概率，p<sub>B</sub>(N, M)为此时B先手赢的概率。

A的先手结束以后，就轮到B的先手。A是随机扔的，所以有20种情况。p<sub>A</sub>(N, M) =  Σ {for i = 1 to 20} 1/20 \*(1 - p<sub>B</sub>(N - i, M))。

B的情况比较复杂。先假设B是瞄准某个格子X扔的，那么先手赢的概率p<sub>X</sub> = 1/3 (1 - p<sub>B</sub>(N, M - X的分数)) + 1/3 (1 - p<sub>B</sub>(N, M - X邻居1的分数)) + 1/3 (1 - p<sub>B</sub>(N, M - X邻居2的分数))。

实际上B是选择最优的格子来瞄准的，所以可以枚举B瞄准的格子，取个概率最大值即可，所以有p<sub>B</sub>(N, M) = max {for x = 1 to 20} p<sub>X</sub>。

比较纠结的情况是N<=20且M<=20，因为有“如果会出现负分，那么就分数不变”的规则，所以，有方程：

p<sub>A</sub>(N, M) =  Σ {for i = 1 to 20} 1/20 \* (1 - p<sub>B</sub>(N - i >= 0 ? N - i : N:, M))

B瞄准X时，p<sub>B</sub>(N, M) = 1/3 (1 - p<sub>B</sub>(N, M - X的分数 > 0 ? M - X的分数 : M )) + 1/3 (1 - p<sub>B</sub>(N, M - X邻居1的分数 >= 0 ? M - X邻居1的分数 : M)) + 1/3 (1 - p<sub>B</sub>(N, M - X邻居2的分数 > 0 ? M - X邻居2的分数 : M))

也就是说p<sub>A</sub>(N, M) 有可能会依赖于p<sub>B</sub>(N, M)，p<sub>B</sub>(N, M)有可能依赖于p<sub>A</sub>(N, M)。这时可以把p<sub>A</sub>(N, M)和p<sub>B</sub>(N, M)看成是两个未知数，联立上面两式，即可解出这个方程组的答案。同样，对于B，要枚举其瞄准的格子，采用概率最大的方案作为当前的答案。

到此为止问题解决。预处理N<=501的所有答案，最后根据输入逐个输出即可。

扩展话题：虽然题目说B的策略比较复杂，总是根据“最优”的概率来瞄准。但根据圆盘里面分数的分布，当N<=20和M<=20时，我们可以猜测：当B的分数是M时，B瞄准分数为M的格子是最好的选择。

如果用这种策略的话，很容易证明：无论M和N是多少，p<sub>A</sub>(N, M)都是一样的。p<sub>B</sub>(N, M)也是如此。因为每一轮游戏游戏，A的胜率是1/20，B的胜率是1/3。我们可以有方程：

p<sub>A</sub>(N, M) = 1/20+ 19/20(1 - p<sub>B</sub>(N, M))

p<sub>B</sub>(N, M) = 1/3+ 2/3(1 - p<sub>A</sub>(N, M))

联立求解，可以得出p<sub>A</sub>(N, M) = 0.136363636364，p<sub>B</sub>(N, M) =  0.909090909091，当N<=20且M<=20。和题目给的SAMPLE N=5时的答案是一样的。

实际上也可以尝试把前面所说的计算方法得出的p<sub>A</sub>(N, M)和p<sub>B</sub>(N, M)输出，我们也会发现他们的值都和N=5的情况一样。




## Problem F. Haunted Graveyard


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4509			| C++		| Accepted		| 0.236 s / 3.000 s			  |


##### Summary
一个N*M(N, M <= 30)的方格阵里面，每移动一次耗费1秒。其中有一些格子不能走，有一些格子可以“瞬移”到另一个格子，而且有可能会导致时间前进或者后退。现在问从(0,0)走到(N-1, M-1)所需的最短时间。如果不可能走到终点则输出Impossible。如果时间永远倒流，那么就输出Never。

##### Solution
带负权边的图的最短路。

因为时间可以“后退”，所以这个图是有负边的。因此这个问题可以用Bellman-Ford算法求解。需要注意的是，如果负环不可达，那么这个负环就不会对结果造成影响。此外，终点没有通往其他格子的边，所以不要对终点做松弛操作，否则有可能会走到另一个负环上。


## Problem G. Slalom


##### Summary

有一个人滑雪，二维平面坐标上有n(n<=1000)个滑雪门，人从起点出发，必须按顺序从这些门之间穿过去，到达最后一个门。问此人从起点到最后一个门的最短距离是多少？

滑雪门使用Y x1 x2表示，表示其两个端点是(x1, Y), (x2, Y)。且保证给出的门是按Y递减的顺序给出的。人只能够从门中间通过，不能绕门而行。
##### Solution

有一个结论：人滑雪的路线必定是由一些线段组成的。而且这些线段的端点必定是起点或者门的两个端点，并有可能有一条垂直于X轴的线段（最后一段，从 某个点直接滑到最后一个门）。

因此对于某端点（起点S或这门的端点）的PA和门B的端点PB（A.y > B.y），如果线段PA PB之间都经过其他门之内，就可以在有向图中连一条有向边。由于滑雪不会逆行回到前一个门，因此构造出来的图必定是一个DAG（有向无环图），可以使用DP求最短路。注意：如果一个点能够垂直到达最后一个门，那么就要检查到这个点的最短路加上垂直到达最后一个门的距离，与最优答案比较，并更新。

但要注意，由于题目的规模比较大，n达到1000，因此不能够枚举任意两个端点，再判断是否经过之间所有的门，这样的做法是O(n<sup>3</sup>)。因此需要有更加高效的方法来进行预处理。可以枚举某个点P，想象有一束光从这个点分散向下照射，下面的每个门相当一条能够通过光线的缝隙。对该点下面的线段逐条枚举，看看这束光线能够照射到下面的哪些线段端点。光线的左右范围可以使用两条射线的斜率的倒数保存（因为射线不可能平行于X轴，但是会平行于Y 轴，因此要用斜率的倒数）。如果这束光线能够照到最底下的门，那么就说明这个点能够直接垂直下到最小面的门，求最短路的时候要特判一下这种情况。 




## Problem I. Happy Telephones


##### Solution
简单题，直接做即可。 



## Problem J. Stammering Aliens


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 4513			| C++		| Accepted		| 0.389 s / 3.000 s			  |


##### Summary
给出一个字符串（长度n<=40000），要找出一个最长的重复了至少K(k<=40000)次的最长的子串。这个子串在原串中可以重叠。如果存在这个子串，则输出这个最长的长度，并输出该子串最右可能出现的位置。如果不存在，则输出none。
##### Solution

首先判断是否可能存在这个子串，如果长度为1的子串也不可能，那么则输出none。

否则二分这个长度，把问题转化成判定性问题。之后可以使用后缀数组或者Hash解决。这里介绍使用Hash的方法。

二分长度K后，仿照RK Hash的方法，每次把字符串中长度为K的串Hash为一个值，存进一个Hash表中，同时统计这个值出现的次数。如果出现的次数大于题目给定的K，那么则更新答案。由于扫描是从右往左进行的，因此一旦发现满足题目要求的(>=K)可以直接更新RIGHT的。

Hash表可以使用前向星数组的Hash表存储，附加一个域存储该值出现的次数即可。




