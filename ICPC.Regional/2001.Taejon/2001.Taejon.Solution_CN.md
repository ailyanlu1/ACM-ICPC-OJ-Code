# The 2001 Asia Regional Contest - Daejon

<table>
<thead>
<th width='40px' align='center'>Id</th>
<th width='500px' align='left'>Problem</th>
<th width='130px' align='left'>Link</th>
<th width='80px' align='left'>Code</th>
</thead>
<tbody>
<tr><td>A</td>   <td>Calendar Game</td>   <td>LA 2321</td>   <td><a href='la2321.cpp'>C++</a></td>   </tr>
<tr><td>B</td>   <td>Wooden Sticks</td>   <td>LA 2322</td>   <td><a href='la2322.cpp'>C++</a></td>   </tr>
<tr><td>C</td>   <td>Modular Multiplication of Polynomials</td>   <td>LA 2323</td>   <td><a href='la2323.cpp'>C++</a></td>   </tr>
<tr><td>D</td>   <td>Human Gene Functions</td>   <td>LA 2324</td>   <td><a href='la2324.cpp'>C++</a></td>   </tr>
<tr><td>E</td>   <td>Flip and Shift</td>   <td>LA 2325</td>   <td><a href='la2325.cpp'>C++</a></td>   </tr>
<tr><td>F</td>   <td>Moving Tables</td>   <td>LA 2326</td>   <td><a href='la2326.cpp'>C++</a></td>   </tr>
<tr><td>G</td>   <td>Farmland</td>   <td></td>   <td></td>   </tr>
<tr><td>H</td>   <td>Square Destroyer</td>   <td>LA 2328</td>   <td><a href='la2328.cpp'>C++</a></td>   </tr>
</tbody>
</table>

年代久远的一套题目，虽然难度不高，但是非常经典。

## Problem A. Calendar Game

##### Summary
A和B玩一个游戏。游戏从某个2001年11月4日以前的日期开始。玩家可以把该日期向后推移一日，也可以把该日期推到下个月的同一日（但如果下个月不存在这个日期的话，则不能这么做，例如不能从1月31日推到2月31日）。谁先把日期推进到2001年11月4日则赢，超过该日期则输。假设A和B都按最优决策进行游戏，给出一个日期，问A先手的话赢还是输。需要考虑平年和闰年。

##### Solution
博弈+找规律。

因为A，B两人都会按最优决策，所以这是一个典型的博弈问题。但题目给出的范围并不大，状态之间的推倒也不复杂，因此可以把所有状态列出来，从2001年11月4日开始往前推，用类似DP的方法找出所有的必胜态和必败态。

但仔细研究会发现这个题目有特别的性质。当前的日期的胜负，仅仅由下一日和下个月的同一日决定。因此可以找找规律。

很容易发现，从2001年11月4日往前推的话，单数日期都是必胜态，双数日期都是必败态。往回退到10月31日，因为11月1日是必胜态，所以10月31日是必败态。然后必胜态和必败态交错出现。到了9月30日，其后继状态是10月1日（必败态）和10月30日（必胜态），所以当天是必胜态。但9月29日也是必胜态，之后重新找到规律，必胜态和必败态交错出现。如此类推，把每个月都计算一遍，就会发现：<b>偶数月的偶数日和奇数月的奇数日是必胜态，其他日子都是必败态</b>，即使是平年闰年也不影响这个规则。但有两个特殊日期：<b>9月30日和11月30日都是必胜态</b>，因为他们后续状态都有一个偶数月的奇数日（必败态）。

只要运用这个规律，直接判断输入的日期的月日的奇偶性即可得出答案。



## Problem B. Wooden Sticks


##### Summary
有一些木材，已知他们的长度l和重量w（记作l, w）。现在用机器加工这些木头。机器准备时间需要一分钟，准备好之后，可以处理参数为(l, w)的木头，如果另一块木头(l<sub>x</sub>, w<sub>x</sub>)满足，l<sub>x</sub> \>= l, w<sub>x</sub> \>= w，那么机器可以顺便把(l<sub>x</sub>, w<sub>x</sub>)也处理而不需要准备时间。如果又有一个木头(l<sub>y</sub>, w<sub>y</sub>)满足l<sub>y</sub> \>= l<sub>x</sub>, w<sub>y</sub> \>= w<sub>x</sub>，那么机器可以顺便把(l<sub>y</sub>, w<sub>y</sub>)也处理而不需要准备时间……如此类推。

问：要处理所有木头，需要多少时间？

##### Solution

贪心，经典NOIP题目“导弹拦截”的变种。

很容易想到一种贪心的方法：先把木头从小到大排序（也就是先比较l，如果相等，就比较w）.然后从排序好的木头里面，从左向右扫描，找出一个关于w的极大的不下降序列（极大的意思就是，当前序列无法通过增加一个木头来得到更长的不下降序列）。因为之前的已经按l排序了，所以找出的这个序列必然能在题目要求中的“一分钟准备时间”之中被处理掉。把序列里的木头标记为已处理。然后再从”未处理”的木头里面继续再找这样的不下降的序列。重复找，直到所有木头都处理为止。找出的关于w的极大不下降序列数目就是答案。

问题在于：为什么可以这样贪心？传说这个和Dilworth定理的对偶定理的证明有关。此外，Dilworth定理为：令(A,≤)一个有限偏序集，并令m是反链的最大的大小。则X可以被划分成m个但不能再少的链。通俗的说，就是反链（题目中的满足l<sub>x+1</sub> \>= l<sub>x</sub>, w<sub>x</sub> \>= w<sub>x+1</sub>）的最大组数 = 最长链（题目中满足l<sub>x+1</sub> \< l<sub>x</sub>, w<sub>x+1</sub> \< w<sub>x</sub>）的节点个数，这意味着，这个题目也可以用动态规划求最大上升子序列的算法解决。


## Problem C. Modular Multiplication of Polynomials


##### Solution
模拟计算题。

多项式的加法和乘法都比较容易处理。主要的难点就是模拟多项式长除法，具体算法可以参看[Wikipedia](http://en.wikipedia.org/wiki/Polynomial_long_division)。

因为题目给出的二进制运算法则很简单，所以实现起来并不难。按多项式长除法算法，不停把除数的最高次的位置对准被除数最高次的位置，然后做减法(被除数减去除数），直到被除数的degree小于除数的degree。这时的被除数就是题目要求的余数了，就可以输出答案。

## Problem D. Human Gene Functions


##### Solution
经典DP。略。



## Problem E. Flip and Shift

##### Summary
有一个环形圆盘，里面放了一些黑色的盘子和白色的盘子（盘子总数目小于30），圆盘可以旋转。圆盘里面有一个装置，可以把位置是X的盘子和X+2的盘子交换（flip操作）。问：是否可以通过这个装置，把黑色的盘子连成一堆（白色的盘子自然也连成一堆了）。
##### Solution

数学规律题（或者说“智力题”）

根据题目给出的规模，会发现广搜是不可能通过的。所以只能够找规律。但这个规律并不容易想。我是看了POJ的Discuss才恍然大悟的。

先把圆盘们的位置看成一个序列，编号为1, 2, 3, 4, ... , N+M。所谓的交换，就是把位置X和X+2的盘子进行对调。如果给出的序列能够通过一些操作，能够把任意位置A和任意位置B的圆盘对调的话，那么就可以使黑子的盘子连在一起。

要根据总盘子数目(N+M)的奇偶性进行讨论：

* 如果(N+M)是偶数，那么flip操作只能把位于偶数位置的盘子换到其他偶数位置，或者把奇数位置的盘子换到其他奇数位置——也就是说，flip操作无法改变奇偶性。设偶数位置的黑色盘子数目为C1，奇数位置的黑色盘子数目为C2。如果|C1 - C2| \> 1的话，那么就无法达成目的。黑色盘子多的位置总会形成一些洞。
* 如果(N+M)是奇数，那么flip操作就有可能把位于偶数位置的盘子换到奇数位置上，或者把奇数位置的盘子换到偶数位置上。原因很简单，在序列的边界进行移动即可做到。例如以1为中心，(N+M)位置就可以和2位置对换。推广一下，这意味着：只要通过一系列操作（可能很繁琐），我们可以把任意位置A和位置B的盘子对调，且不影响其他位置的盘子。

为什么说，只要能把奇数位置的盘子换到偶数位置上去（或反之），就可以做到“把任意位置A和任意位置B的圆盘对调且不改变其他位置”？这个构造一下对调的方案即可。为了简便，只需要构造出把位置1的盘子移到某奇数位置或者偶数位置上的方案即可。

1. 把位置1的盘子换到奇数位置B上去：不停把1往右对调……，再把B-2位置的盘子（这个盘子原来在B位置上）往左对调回1，即可实现1和B实现对调。
2. 把位置1的盘子换到偶数位置B上去：不停把1往右对调（要通过序列的边界），然后再把位置B-2的盘子（这个盘子原来在B位置上）不停往右对调（要通过序列的边界）回位置1上……。即可把1和B实现对调。


## Problem F. Moving Tables


##### Solution
经典贪心，略。



## Problem H. Square Destroyer

##### Solution

该题目可以转化为一个重复覆盖模型：用现有的边去覆盖现有的正方形，最少要用多少条边。因此可以使用Dancing Link进行搜索。

题目的预处理比较麻烦。可以先把在不同Size的情况下，每条边能够覆盖哪些正方形预处理出来。 


