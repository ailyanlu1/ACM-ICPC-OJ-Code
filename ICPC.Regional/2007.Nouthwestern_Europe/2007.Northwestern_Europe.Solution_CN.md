# The 2007 Northwestern Europe Regional Contest

<table>
<thead>
<th width='40px' align='center'>Id</th>
<th width='500px' align='left'>Problem</th>
<th width='130px' align='left'>Link</th>
<th width='80px' align='left'>Code</th>
</thead>
<tbody>
<tr><td>A</td>   <td>Assemble</td>   <td><a href='http://poj.org/problem?id=3497'>POJ 3497</a></td>   <td><a href='la3971.cpp'>C++</a></td>   </tr>
<tr><td>B</td>   <td>March of the Penguins</td>   <td><a href='http://poj.org/problem?id=3498'>POJ 3498</a></td>   <td><a href='la3972.cpp'>C++</a></td>   </tr>
<tr><td>C</td>   <td>Containers</td>   <td><a href='http://poj.org/problem?id=3499'>POJ 3499</a></td>   <td><a href='la3973.cpp'>C++</a></td>   </tr>
<tr><td>D</td>   <td>Youth Hostel Dorm</td>   <td></td>   <td></td>   </tr>
<tr><td>E</td>   <td>Escape from Enemy Territory</td>   <td><a href='http://poj.org/problem?id=3501'>POJ 3501</a></td>   <td><a href='la3975.cpp'>C++</a></td>   </tr>
<tr><td>F</td>   <td>Flight Safety</td>   <td></td>   <td></td>   </tr>
<tr><td>G</td>   <td>Summits</td>   <td></td>   <td></td>   </tr>
<tr><td>H</td>   <td>Obfuscation</td>   <td><a href='http://poj.org/problem?id=3504'>POJ 3504</a></td>   <td><a href='la3978.cpp'>C++</a></td>   </tr>
<tr><td>I</td>   <td>Tower Parking</td>   <td><a href='http://poj.org/problem?id=3505'>POJ 3505</a></td>   <td><a href='la3979.cpp'>C++</a></td>   </tr>
<tr><td>J</td>   <td>Walk</td>   <td></td>   <td></td>   </tr>
</tbody>
</table>

本套题目由于完成时间久远，所以没有详细的解说。见谅。
## Problem A. Assemble


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 3971			| C++		| Accepted		| 0.022 s / 3.000 s			  |


##### Solution
二分。


## Problem B. March of the Penguins


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 3972			| C++		| Accepted		| 0.303 s / 3.000 s			  |

##### Solution
网络流。


## Problem C. Containers


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 3973			| C++		| Accepted		| 0.033 s / 3.000 s			  |

##### Solution
略。


## Problem E. Escape from Enemy Territory


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 3975			| C++		| Accepted		| 0.349 s / 3.000 s			  |


##### Solution
二分答案+BFS。


## Problem G. Summits


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 3977			| C++		| Accepted		| 0.206 s / 3.000 s			  |


##### Solution
用BFS做Floodfill。

首先，能够成为summit的点，必定是高度比较高的。所以首先把所有点从高到低排序。

然后依次从排序结果里面选出点X，判断它是不是summit。这时需要一个类似floodfill的算法。

明显，某个点X，通过高度大于h<sub>X</sub>-d的格子到达的区域，必定不可能是summit。所以我们可以用floodfill算法，从X出发，用BFS把这些区域标记出来。同时在标记的过程中，我们可以判断点X是否是summit。

判断的方法是： 每次从X扩展邻居的四个点，会有以下可能：

1. 邻居点的高度<=h<sub>X</sub> - d。根据题目意思，这个点是一个“沟”，不需要扩展。
2. 邻居点在当前这一轮BFS被搜索过的，跳过。
3. 邻居点在之前的BFS被搜索过的。如果遇到这种情况，那么就说明X不是summit。因为如果这个邻居点之前被搜索过的话，就说明这个邻居点必定通向某个点Y，h<sub>Y</sub> > h<sub>X</sub>（因为之前从高到低的排序）。也就是说这个邻居点的高度必定大于h<sub>x</sub> - d。这意味着，X必定可以通过这个邻居点到达一个更高的点，且这条路径上所有点的高度都大于h<sub>X</sub> - d。所以，X点不是summit。

PS：这个题目也可以用是并查集解决。



## Problem H. Obfuscation


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 3978			| C++		| Accepted		| 0.019 s / 3.000 s			  |

##### Solution
动态规划。


## Problem I. Tower Parking


OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
ACM-ICPC Live Archive 3979			| C++		| Accepted		| 0.003 s / 3.000 s			  |

##### Solution
简单模拟题。

上下电梯所花的时间仅仅与每一层楼有多少辆车有关。然后每一层楼的车在转盘上移动的时间的计算是独立的，可以逐层计算。计算转盘的耗时时，可以想象是出口在转动，不停地转到需要出来的车的位置，而不是转盘在转动。这样设计出来的算法会非常简单。