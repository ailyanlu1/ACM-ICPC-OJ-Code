# 2010 East Central NA: Pro-Test Voting

## Solution

动态规划问题。

设DP[i][j]表示计算了前i个选区，恰好花了j单位的钱时，所能够得到最大的票数。易得：DP[i][j] = max(DP[i-1][j-k] + get(i, k))。上式中k取遍0到j。get(i, k)表示第i个选取选区花费k元能够获得的票数。最终答案即是DP[n][money]。

问题比较棘手的地方是要输出一个字典序最大的答案。我们可以这样考虑这样的方法，把输入的项目倒序输入：要使字典序最大，可以在每次进行DP的时候，在max(DP[i-1][j-k] + get(i, k))的前提下，使k尽量大，也就是j-k尽量小，这样能够保证最终的字典序最大。其原理是：设use[i]是在满足最终答案最优的前提下，第i个选区使用的票数。在进行DP的时候，我们希望use[i]尽量大，也就是sum(use[i+1], use[i+2], ... ,use[n])尽量小。若我们采用上面的方法时，k对应以上的use[i]，j-k对应sum(use[1], use[2] , ..., sum[i-1])。因为我们是逆序输入，以上方法恰好能使字典序最大。 
