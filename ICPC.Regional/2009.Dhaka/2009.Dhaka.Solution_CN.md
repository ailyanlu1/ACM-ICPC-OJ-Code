# Problem A. That is Your Queue
## Solution

题目中的数据结构的模型为双端队列模型。由于只有1000次询问，因此编号为1000以后的人，如果不通过E命令放到最前面，是不可能访问到的。因此可以仅把前1000个人放到双端队列的里面，进行模拟即可。双端队列可以使用数组模拟，提取一个人到最前面，可以先在当前队列找到该人的位置，将其设成-1，表示该位置为空即可。然后把此人放到双端队列的头即可。



# Problem B. How Many Ones Needed?
## Summary
给出a,b，问[a,b]中所有数字转换成二进制后一共有多少个1。
## Solution

设函数F(x)能够计算0-x中所有二进制数字1的个数。

观察规律：
<pre>
数字 二进制
0   0000
1   0001
2   0010
3   0011
4   0100
5   0101
6   0110
7   0111
8   1000
9   1001
10  1010
11  1011
....
</pre>

可以观察到，有倍增的规律。也就是说，2-3的二进制是0-1的二进制前面加多一个1。4－7的二进制是0-3的二进制前面加多一个1，8-15的二进制是0-7的二进制前面加多一个1。

另0至DP[x]为2x-1中所有二进制数字1的个数，明显有：DP[1]=1,DP[x]=DP[x-1]+2x-1。

可以利用DP[x]统计出F(x)。设B(X)为小于等于X的最大的2的幂的指数（也就是说，B(X)是满足2B(X)<=X最大的数字）。例如，统计F(13)。由于DP[3]记录了0-7的二进制位数，而8-13的二进制数就是0-5的二进制前面加一个1。因此一共增加了13-8+1个1，而0-5有多少个二进制位可以利用F(x)函数进行递归计算。因此有递归函数

F(X) = DP[B(X)] + F(X-(2B(x)))+ X - 2B(x) + 1。

且F(1)=1,F(0)=0。 




# Problem C. Foot Notes
## Solution
动态规划问题。

可以预先处理出从第i行到第j行，需要多少个脚注，保存在need[N][N]数组中。需要特别注意，题目中有同一行出现多个相同脚注的现象，要特殊处理。

然后动态规划求解。设dp[i]为解决了前i行的脚注问题，需要的最小脚注数量。此外，我们后面不会再利用这前i行的页面空间，而是新开一页。新开一页的操作有转移方程：

dp[i] = min(dp[j] + need[j+1][i])，限制条件：i - j + need[j+1][i] <= s，也就是不能超过一页的行数限制。在此页解决i-j行，这些行里面的脚注又是预先处理出来的，因此求解十分简单。

dp[n]就是最终答案。 


# Problem D. A Match Making Problem
## Solution
秒杀题，题目中女人数量为废条件。



# Problem E. Games of Block
## Solution
对于每个CASE,直接进行记忆化搜索.每个状态可以用一个三进制数字表示(没有为0,还有B,R),由于状态数众多,因此要使用Hash表保存状态.

抽象成状态后,就是一个在DAG图进行DP的问题.对于一个状态,如果其所有后继状态都是win的,那么这个状态就是loss,如果该状态有一个后继状态是loss的,那么这个状态就是win的.(也就是必败态的定义)然后状态0就是loss,使用记忆化搜索可以解决问题.

题目还要求在loss情况下的最多步数和在win情况下的最小步数.如果一个状态是loss,那么就从其所有后继状态中选出最大步数+1,作为当前状态loss时的最大步数.如果一个状态是win,那么就从其所有后继状态中选出为loss的最小步数+1,作为当前状态win时的最小步数.



# Problem G. Camera in the Museum
## Solution
可以证明，摄像头肯定是安装在墙壁上，比安装在内部有更大的视野。

因此可以找出对于每个点，在墙壁上的盲点区间。最后找出墙壁盲点数目最少的一段即可。 


# Problem H. Traffic Jam
## Solution
官方给出的解题报告很精简，下面是详细展开。

由于飞行是可以在任意道路起飞，在任意道路降落。明显，如果把所有线段上的点离散出来，然后求出两两之间飞行的点距，建图，那么这就是一个最短路问题。然而，这种做法明显是不现实的。因此，我们需要对线段上的点进行筛选，找出我们感兴趣的“兴趣点”，并证明必须在这些“兴趣点”上起飞或者降落必定是最优的。

要解决这个问题，需要进行一些大胆的猜想，并证明这些猜想。
* 猜想1：线段端点之间可以飞行。
* 猜想2：从任何点A飞到直线PQ上，然后再行进到端点P或者Q，最佳方案唯一，飞行方向与PQ的α夹角为arccos(F<sup>-1</sup>)。

证明：

![Problem H Image 1](4500_Img1.jpg "Problem H Image 1")

如图：假设点P是平面上面的任意一点，P需要飞行到线段AB上，然后到达点A。从P向AB做垂线，垂足为H。明显，从P起飞，必定在AH段降落，才能够达到消耗最少的燃料。

设PH长度为D1，AH长度为D2，这些都是常数。S(x)代表从P飞行到AB再到达A的最少耗油，x为图中的夹角α。根据三角关系，有：

* S(x)=D1*F/sin(x)+D2-D1[cos(x)/sin(x)]
* S(x)=D1*(F-cos(x))/sin(x) + D2 

明显，上述D1,D2都是常数，那么我们只需要关注新的函数：f(x)=(F-cos(x))/sin(x)何时能够去最小值即可。对f(x)求导，有： 
* f'(x)=1-[cos(x)(F-cos(x))]/sin<sup>2</sup>(x)

当f(x)达到极值时，有f'(x)=0，有
* f'(x)=1-[cos(x)(F-cos(x))]/sin<sup>2</sup>(x)=0
* cos(x)F-cos<sup>2</sup>(x)=sin<sup>2</sup>(x)
* cos(x)F=1

得最终答案：cos(x)=F<sup>-1</sup>

因此，上图的C1,C2就是我们要找的“感兴趣点”，当然，这些感兴趣点必须要在已知线段上。 

* 猜想3：必须从线段端点向其他线段的内部飞行，才可能最优。这个猜想尚未严格证明，结题时只是画图能够看出来。假设从线段AB向线段CD飞去最终到达D，在AB上任一个点起飞，以arccos(F<sup>-1</sup>)的角度飞抵CD。可以看出，如果AB中，dist(A,D)<dist(B,D)，那么必定是在A点出发达到最优，比从AB之间任意点出发都要好。反之，必定是在B点出发达到最优。 

综上，飞行的起点就是线段的端点和我们通过几何计算求出来的感兴趣点。那么整个结题的步骤，就是先把这些点找出来，然后建图。凡是飞行的，距离一律乘以f。使用最短路算法求出最短路就是答案。注意：道路是单向的，飞行是双向的。



# Problem J. How Many Bases?
## Solution
中等的数学题目。

对给出的x=N<sup>M</sup>进行质因数分解：N = c<sub>1</sub><sup>Mk1</sup>c<sub>2</sub><sup>Mk2</sup>..c<sub>m</sub><sup>Mkm</sup>，如果要使x在B进制下恰好有T个后缀0，那么B必定满足以下条件：

B必定与x有相同的质因数因子，否则不可能有后缀0。因此，在这个题目中，我们并不关注因子，而是关注因子的系数。因为因子的系数决定了有多少个后缀0。我们要关注这些后缀0是怎么产生的。例如题目给出的24，在3进制的情况下，由于24 mod 3 ＝ 0，但24/3 mod 3 ≠ 0，因此有一个后缀0。在2进制的情况下，24有3个后缀0，可以猜想，24=3<sup>1</sup> × 2<sup>3</sup>，在十进制向二进制转换的过程中，由于有2<sup>3</sup>这个因子，可以使其连续3次得到0。

设B=c<sub>1</sub><sup>b1</sup>c<sub>2</sub><sup>b2</sup>..c<sub>m</sub><sup>bm</sup>，这些因子与x的因子一一对应。那么B满足以下条件：

对于，B所有质因数的系数b<sub>i</sub>，满足b<sub>i</sub>≤k/T，且必须有其中一个质因数的系数，附加满足k/(T+1)&lt;b<sub>i</sub>≤k/T。这样才可能使x在这些进制之中恰好有T个后缀0。

题目的答案就是在满足上述限制条件下的B的质因数系数的组合方案数。

例如题目给出的24=3×2<sup>3</sup>，已得，如果对因子2满足k/(T+1)&lt;b<sub>i</sub>≤k/T条件，若T=1，进制B的2因子系数可以取2到3，同时3的系数可以取1和0。若3的系数取1到1，那么2的系数可以取0到3。也就是：

若质因数2满足附加条件，2的系数要满足k/(T+1)&lt;b<sub>i</sub>≤k/T，也就是1&lt;b<sub>i</sub>≤3。3的系数要满足b<sub>j</sub>≤k/T，也就是b<sub>j</sub>≤1。

* 2<sup>2</sup> × 3<sup>0</sup>
* 2<sup>2</sup> × 3<sup>1</sup>
* 2<sup>3</sup> × 3<sup>0</sup>
* 2<sup>3</sup> × 3<sup>1</sup>

2的系数取值区间为[2,3]，3的系数取值区间为[0,1]，组合有2 × 2=4种

若质因数3满足附加条件，3的系数要满足k/(T+1)&lt;b<sub>i</sub>≤k/T，也就是0&lt;b<sub>i</sub>≤1。2的系数要满足b<sub>j</sub>≤k/T，也就是b<sub>j</sub>≤3


* 3<sup>1</sup> × 2<sup>0</sup>
* 3<sup>1</sup> × 2<sup>1</sup>
* 3<sup>1</sup> × 2<sup>2</sup>
* 3<sup>1</sup> × 2<sup>3</sup>


2的系数取值区间为[0,3]，3的系数取值区间为[1,1]，组合有4 × 1=4种

对于质因数超过2个的数字亦有相似推论。

明显，我们看到上述计算方法，枚举某个质因数系数满足k/(T+1)&lt;b<sub>i</sub>≤k/T，让其他质因数系数满足b<sub>j</sub>≤k/T的组合计算是有重复的。这时，我们需要使用容斥原理来把重复的计算去掉。如果进制B有m个质因数，那么我们可以逐个枚举这些质因数，假设该质因数的系数满足k/(T+1)&lt;b<sub>i</sub>≤k/T这个附加条件，其他质因数的系数则满足b<sub>j</sub>≤k/T。这样我们需要进行m次计算，然后累加。这些累加是有重复的。那么我们就两两枚举这些计算过程找出其的重复计算的部分（这个很容易），减去。然后三三枚举这些计算过程找出其的重复计算的部分，加上……如此类推，很方便地就可以计算出正确的答案。这就是容斥原理在这个题目之中的应用。

例如上面的例子：因子2与因子3的计算有重复。2系数重叠区间为[2,3]，3系数重叠区间为[1,1]，重叠大小为2×1=2，由于是两个集合组成，根据容斥原理，应该在上述2×2+4×1的和上面减去2×1，最终得到6，这也就是最后的答案。

又例如，对于某个数字，第1个因子系数的附加条件限制区间为[1 5]，第2个因子的是[3 4]，第3个因子的是[2 4]。那么第1次计算得到的组合数是[1 5][0 4][0 4]=4×5×5；第2次计算得到的组合数是[0 5][3 4][0 4]=6×2×5；第3次计算得到的组合数是[0 5][0 4][2 4]=6×5×3；第1,2次计算的重复部分是[1 5][3 4][0 4]=5×2×5，符号负；第2，3次计算的重复部分是[0 5][3 4][2 4]=6×2×3，符号负；第1，3次计算的重复部分是[1 5][0 4][2 4]=5×5×3，符号负；第1，2，3次计算之间的重复部分是[1 5][3 4][2 4]=5×2×3，符号正。累计起来就是最终答案。


# Problem K. Integer Game
## Solution


