# POJ Monthly Contest – 2009.04.05: The merchant

## Summary

给出一棵N个节点的树，每个节点有一个权值wi。需要回答Q个询问，每次询问给出两个节点A,B。要你从A到B的路径上(注意是单向的)，找到两个点，使得后经过的那个点的权值与靠前那个点权值的差值最大，输出该最大差值(如果最大差值为负则输出0)

数据范围：1 ≤ N, wi, Q ≤ 50000。
## Solution

由于树的形态是不变的，因此可以使用离线算法。这个题目与LCA有点类似，对于询问x,y，我们可以知道，所求的最大值可以出现在x-LCA(x,y)这一段，也可能出现在LCA(x,y)-y一段，也有可能出现在横跨LCA(x,y)，也就是x-y这一段。因此，我们每个节点x维护四个权值：

* mi[x]：从x到LCA[x,U]中的最小权值。
* ma[x]：从x到LCA[x,U]中的最大权值。
* opt1[x]，从x到LCA[x,U]中能够取到的最优值，注意方向，是向根的。
* opt2[x]，从LCA[x,U]到x中能够取到的最优值，注意方向，是背根的。

U这个点是询问x,y中的最近公共祖先。我们只要利用类似Tarjan算法的做法，每次求出处理完一个子树后，就对Tarjan算法所维护的并查集进行路径压缩，同时维护mi,ma,opt1,opt2四个值进行维护。

还有一个问题：Tarjan算法对于询问(X,Y)，在DFS遍历时有着先后的顺序，如果Y后被遍历，那么刚好X与LCA(X,Y)同在一个集合，但此时Y并不与LCA(X,Y)在同一集合，那怎么知道Y到LCA(X,Y)这条路径的值呢?

这里有两种方法：一种是将每个节点的边的顺序反过来，再次DFS，则此时Y先被遍历。而更方便的是：我们可以在DFS回到LCA(X,Y)时再次询问Y，此时显然Y与LCA(X,Y)在同一集合，此时就可以回答询问(X,Y)了。
