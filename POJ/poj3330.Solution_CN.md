## 2007 Japan Domestic: Dr. Podboq or: How We Became Asymmetric

OJ and Id							| Language	| Status        | Run Time / Limit            |
-----------------------				| --------	| ------------- | -------------               |
POJ 3330							| C++		| Accepted		| 1125 ms / 2000 ms           |
Aizu OJ 1152						| C++		| Accepted		| 0.02 s / 8 s           	  |

##### Summary
题目用括号表示法给出一棵满二叉树，并定义了每个节点上left-right similarity值的计算方法。最后要求把这棵满二叉树变换为符合题目中所描述的”最非对称“的形态。题目中允许的变换方法是交换一个节点的左右儿子。

##### Solution
树上繁琐的操作（但并不难）

第一步要读懂题目，题目有点难理解。读懂题目以后，我的思路是：

1. 递归parse输入的字符串，还原成二叉树
2. 按照题目的定义，对二叉树进行DFS，求出每一个结点的left-right similarity值。这一步应该是最麻烦的。
3. 再次DFS，根据之前计算出的left-right similarity值，如果有需要则进行左右儿子的交换。这里我们需要另一个递归函数，用于比较左右儿子的对称性强弱。这个函数按照题目给出的要求去实现即可。


求left-right similarity值是题目最麻烦的步骤。我的方法是在DFS的函数中添加一个参数，是一个set。里面存储了当前所找到的所有子树的形态。这样，我们就可以对当前节点的两个儿子所拥有的子树（都存储在set里面）进行对比，找出他们的交集和并集，这样就求出其left-right similarity值了。

子树可以仿照题目给出的格式，用带括号的字符串表示。根据题目关于left-right similarity值的定义，交换某节点的左右儿子并不影响这个值的计算。为了正确表示同构的子树，避免重复计算，我们可以对题目输入的树进行小小的变换。我们规定：这课满二叉树的左儿子下面叶子的数目，一定要多于右儿子下面的叶子数目。否则我们就交换左右节点。对输入的树进行这个变换以后，可以保证：里面所有同构的子树的形态必定相同。这样，我们就可以放心地用括号表示法去表示每一棵子树的形态了。

我的方法时间上来说并不是最优。但比较容易理解和实现。应该有更加高效的处理方法。