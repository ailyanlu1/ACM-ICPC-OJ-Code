# Problem A. An Industrial Spy
## Solution
简单题，筛素数之后穷举。筛素数后先枚举用哪几个数字，然后枚举这些数字组成的排列组合（用next_permutation)，最后判断这个数字是否是素数。如果是，它就满足要求。注意不要重复计算即可（要无视这些数字的前置0）。

# Problem B. Common Subexpression Elimination

# Problem C. Divisible Subsequences
## Summary
有一个长为n(n<=50000)的数字序列，问该序列中有多少个连续的子段，其数字和能够整除给定的d。
## Solution

首先对数字序列进行求和预处理，得到sum数组，求和子段[x..y]=sum[y] - sum[x-1]，且sum[0]=0。

子段[x..y]求和=sum[y] - sum[x-1]，若(sum[y] - sum[x-1]) mod d == 0，那么有sum[y] mod d = sum[x-1] mod d。

因此，求出sum数组后，sum每个数对d求模。然后该sum数组里面有多少对相同的数字，就是最终答案。

# Problem D. Fractal

# Problem E. Mountain Road
## Solution

注意一辆车最少用时间D通过瓶颈，但它可以以大于D的时间走。

使用dp\[200\]\[200\]\[2\]表示状态：dp\[i\]\[j\]\[0/1\]表示两边各走了i j部车，0：刚刚是A边走完，1:刚刚是B边走完.

最重要的一点是：转移的时候要枚举此后连续走K部车。

重要的是要理清车怎么跑：

首先确定某辆车实际的出发时间st是<b>车到瓶颈的时间T</b>和<b>上一部车出发后+10</b>的最大值

到达瓶颈另一端的时间re是<b>车出发后全速前进</b>和<b>上一部车到达后+10</b>的最大值

这样就保证了“2车通过同一个点的时间间隔要至少是10秒”。

那么此时车行驶时间是ti=re-st。 

# Problem F. Moving to Nuremberg
## Summary
经典问题，求一棵结点带权的树的中心。 
## Solution

使用DFS可以得到答案。给树一个DFS序，设ff[x]为结点x的权值，w[a,b]为a、b边上的权值，up[x]为x结点向上走得到的所有带权路径长度总和，down[x]为x结点向下走得到的所有带权路径长度总和，cup[x]为x结点向上的所有结点的权值的总和，cdown[x]为x结点向下的所有结点的权值的总和。

第一次DFS，计算down[x]和cdown[x]，有：
<pre>
down[x] = 求和 {down[x的儿子i] + cdown[x的儿子i]*w[x,x的儿子i]}
cdown[x]=ff[x] + 求和 {cdown[x的儿子i]}
</pre>
第二次DFS，计算up[x]和cup[x]，有：
<pre>
cup[x] = cup[x的父节点] + cdown[x的父节点] - cdown[x];
up[x] = up[x的父节点] + down[x的父节点] - down[x] - cdown[x] * e + cup[x] * e;
注意当x为根时，这两个值都为0、
</pre>
最后，对于每个结点x其答案就是up[x]+down[x]，检查更新得到最优解即可。 


# Problem G. Room Assignments
# Problem H. Settlers of Catan
## Solution
首先要想一个办法对这个六边形的矩阵编坐标。一种比较简单的方法是：把整个图顺时针转30度，然后设中心所在的格子为原点(0,0)，那么其外围一圈的格子（2,3,4,5,2,3的那一圈）的坐标就分别是(1,0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)。其他格子的坐标如此类推。

然后要找出按照题意所叙述的按螺旋状扩展格子的方法。以(1,0)这个格子为例，下一步的格子必定满足：1）未曾被访问过，2）与(1,0)相邻，3）与内层的螺旋相邻。于是就可以从(x+0, y+1)这个方向开始，按逆时针方向枚举其邻居，看看邻居哪个格子符合上述条件。如果找不到这样的格子，就意味着当前这一层螺旋已经走完了，要扩展到外面的一层螺旋。这时往(x+1,y+0)这个方向移动一步即可。

找到了扩展的规律，省下的事情就好办了。找出1-5资源中符合条件的一种放进去即可。

# Problem I. Simple Polygon
## Summary
给出平面上n个点，要求一个简单多边形出来，包含所有的点。（简单多边形可以凹凸，但是边不能相交）
## Solution
有一个相当直观的做法：

1. 先对点按x大小排序，如果x相同则按y大小排。
2. 求出这些点集的下半部分的凸包
3. 凸包以上的点采用锯齿的方法连起来。由于之前已经按x,y排过序，所以锯齿状的形状也很容易得到。

可以参看下面这张示意图：

![Alt text](https://github.com/pkkj/ACM-ICPC-OJ-Code/raw/master/ACM-ICPC-Live-Archive/2009.Northwestern_Europe/2009.Northwestern_Europe.Solution_Img1.jpg "Image 1")
# Problem J. Wormholes
