# 2009 Harbin: Fuzzy Google Suggest

## Solution

使用Trie树＋DFS解决。

先把单词用Trie树存储起来，并使用辅助数组cnt标记经过Trie节点x的单词数目，方便统计某前缀若成功匹配节点x时，一共匹配了多少个单词。

然后使用dfs(int x, int p, int ed)函数在Trie树上进行搜索，并返回该前缀能否成功匹配。设当前的单词为str，其中x表示当前搜索到的Trie树的节点，p代表当前单词匹配到的位置，ed表示还剩下多少可用的编辑距离。明显有如下情况：

* 如果存Trie树中存在str[p]的节点，那么可以有：dfs(next,p+1,ed)。Trie树向下推进一个节点，单词指针向后移动一位，可用编辑距离不变。
* 如果Trie树中不存在str[p]的节点，那么就必须动用编辑距离来改变当前单词了。根据编辑距离的定义，有三种策略需要尝试： 
  1. 在str[p]前一个位置插入一个字母，使其与Trie树的当前状态匹配，表现为dfs(next,p,ed+1)，由于是插入字母，因此单词指针p不用推进。
  2. 更改str[p]位置一个字母，使其与Trie树的当前状态匹配，表现为dfs(next,p+1,ed+1)。
  3. 删除str[p]位置的字母，表现为dfs(x,p+1,ed+1)，由于是删除字母，因此Trie树的指针不用推进。 

使用vis数组标记Trie树各个节点的匹配情况，一开始设为0。vis[x]=0表示经过节点x不能够到达成功匹配的节点，vis[x]=1表示 经过节点x能够到达成功匹配的节点，vis[x]=2该节点被一个前缀成功匹配（到达前缀的“尾巴”）。DFS时，如果ed为负数，那么说明匹配失败。如果当前前缀能够成功匹配到结尾，则把vis[x]标记为2，且该点以上的节点全部标记为1。当dfs到一个vis[x]=2的节点时，则无需要再dfs下 去，因为在前一次的匹配中已经判定该节点被成功匹配了。

之后使用dfs2函数统计Trie树上哪些节点被匹配了。从Trie树的根开始向下扫，当发现vis[x]＝1，说明该路径有可以匹配的节点，需要向下扫。当发现vis[x]=2时，说明这是一个被匹配的前缀，ans+=cnt[x]，然后就返回，不用管下面的vis[y]=2，因为 cnt[x]已经包含了cnt[y]。这样就避免重复计数。如果vis[x]=0就不用看了，因为下面没有被匹配的前缀。

由于询问次数和编辑距离都很小，所以算法的复杂度很低。 
