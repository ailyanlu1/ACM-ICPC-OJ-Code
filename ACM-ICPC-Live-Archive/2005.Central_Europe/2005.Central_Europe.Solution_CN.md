# Problem B. The Cow Doctor
## Summary

给出m个集合，里面存在n种元素。求这些集合中哪些集合可以被其他集合并得到的（精确相等）.
##  Solution

设集合A能被其他集合B1, B2, ... Bi并得到，则B1, B2, ... Bi显然都属于A. 因此，我们可以找出所有属于A的集合B1, B2, ... Bi，求它们的并，看是否等于A.

注意, 题目有一个trick, 有可能有些集合是相等的. 这个时候要特判. 最好的方法是将集合按大小从大到小排序, 然后每次扫描只扫描后面的. 这样就避免了集合相等发生的错误, 也减少了算法的常数时间.

复杂度O(m ^ 2 \* n)，具体实现可以使用bitset, 当然也可以自己写一个基于位运算的集合. 可以使用5个long long存储这个集合. 


# Problem C. Word Rings
## Summary

给出n个(n<=100000)长方体(0, 0, 0) - (ai, bi, ci),求它们并的总体积.

## Solution

主要的解题思想是使用线段树进行降维.

第一个降维的方法是将所有正方体按照z轴排序, 将他们的顶从高向低排. 按这种顺序处理长方体, 其xOy面的面积并只增不减.

第二个降维是我们能够使用一维线段树来存储xOy平面上的信息, 动态计算面积并. 我们不断地往平面中加入长方形, 使用线段树来维护信息. 在下面的代码中, 线段树节点l,r表示其x轴的范围, y代表y方向的高度. 对于一个节点T[p], 如果它不是混合节点(也就是高度都是一样的), 那么其面积就是T[p].y * (T[p].r - T[p].l). 如果它是混合节点, 那么我们就可以从其儿子节点中获得面积信息: T[p].s = T[T[p].ls].s + T[T[p].rs].s.

线段树节点中的min和max字段是用来加快速度的. 明显, 如果要插入的y小于当前区间的最小高度min, 那么就可以直接跳出. 如果要插入的y大于当前区间的最小高度, 且插入区间包含了当前线段树节点的区间, 那么就直接插入, 无需管左右儿子.



# Problem E. Find the Clones
## Solution
可以先把数字转成4进制的long long, 然后排序统计即可. 



# Problem F. The Warehouse
## Solution
普通的广搜. 由于地图是变的, 因此可以使用一个set来进行判重(虽然效率很不理想, 但是实现简单). 使用set判重必须重载一个小于号.



# Problem G. Widget Factory
## Solution

可以使用高斯消元解这个方程。未知数就是每一种部件的生产时间，可以得到一组方程：

(A<sub>11</sub>x<sub>1</sub>+A<sub>12</sub>x<sub>2</sub>+...A<sub>1n</sub>x<sub>n</sub>） mod 7 ＝ D mod 7

解的时候要时时注意使每个数字都在0-6的范围内，且最后答案是在3-9的范围内。




# Problem I. Wild West
## Summary

给出一个单词表，给一个回龙接单词的规则，问给出一个单词回龙拼接的环，使这个环上的单词的长度平均值最大。 

## Solution
使用二分+Belleman判断的方法可以解决。每次二分一个答案k，设每个单词的长度为wi，那么在判断时，图的新的边权就是k-wi。如果使用Belleman判断图中存在负环，就证明存在一个接龙，满足Σ(k - wi) < 0，即Σ(wi)/n \> k，这就意味着这个平均值是可以达到的。 
